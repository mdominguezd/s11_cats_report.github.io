## Baseline scenario

### Main findings

The main finding of the interviews were the steps followed currently to discover, retrieve and visualize data. These steps are summarized on @fig-baseline and show how complex and time consuming the process of discovering and visualizing spatial data can be for a Satelligence employee nowadays. Moreover, the steps followed were categorized in four classes depending on how much time is generally spent carrying out.

![Baseline workflow](img/Baseline_data_discovery_workflow.png){#fig-baseline width="100%"}

The major pitfalls found on the process of data discovery in the company could be summarized in ....

## Service integration

*Explain here how eoAPI uses multiple services, how each of them helps S11 in their data discovery and vizz tasks, and how did I manage to deploy it*

Kubernetes

STAC-API, pgSTAC, TiTiler

### Data discovery improvement

Flowchart with STAC

## Performance of multi-format data visualization

TiTiler-PgSTAC & TiTiler-xarray

### Raster formats

```{python}
#| echo: false

import pandas as pd

6data = pd.read_csv('https://raw.githubusercontent.com/mdominguezd/s11_cats_report.github.io/main/sections/request_time_results_1iter.csv')

speed_up = float(round(data['ZARR'].mean()/data['COG'].mean(), 2))
```

The comparison of visualization speeds with TiTiler-xarray for Zarr datasets and TiTiler-PgSTAC for COGs are presented on @fig-format-comp. In the figure it can be obesrved that COG tiles are requested `{python} speed_up` times faster than the same file in ZARR format.

```{python}
#| echo: false
#| fig-cap: "Request times depending on data format and zoom level"
#| label: fig-format-comp

import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap

s11_cmap = LinearSegmentedColormap.from_list('s11', ['#96d7fa', '#ff0000'])
background_color = '#180066'
text_color = 'white'

sns.set(rc={'axes.facecolor' : 'white',
    'grid.color' : 'lightgray',
    'text.color' : background_color,
    'axes.labelcolor' : background_color,
    'xtick.color': background_color,
    'ytick.color': background_color,})

fig, ax = plt.subplots(1,1,figsize= (7.5,5))

sns.boxplot(data[['COG', 'ZARR']], palette = {'COG':s11_cmap(0), 'ZARR':s11_cmap(255)}, ax = ax, linecolor=background_color)
# sns.despine(trim = True, offset = -10, ax = ax)

ax.set_ylabel('Request time [s]')
a = ax.set_xlabel('Data format')

```


### Effects of zoom level

```{python}
#| echo: false

import statsmodels.api as sm
data = pd.read_csv('request_time_results_6iter.csv')


fit_results = sm.OLS(data['COG'], sm.add_constant(data['zoom level'])).fit()
cog_slope = float(round(fit_results.params['zoom level'], 3))

fit_results = sm.OLS(data['ZARR'], sm.add_constant(data['zoom level'])).fit()
zarr_slope = float(round(fit_results.params['zoom level'], 3))
```

As seen on @fig-comp-zoom, the zoom level of the map will have an effect on the time spent requesting and getting a tile from a tile server. In this study, it was found that the request times decreased by a factor of `{python} cog_slope` and `{python} zarr_slope` per zoom level for COGs and ZARRs respectively.

```{python}
#| echo: false
#| fig-cap: "Request times depending on zoom level"
#| label: fig-comp-zoom
fig, ax = plt.subplots(1,1,figsize= (7.5,5))

sns.regplot(data, x = 'zoom level', y = 'COG', ax = ax, color=s11_cmap(0), ci = 95, label='COG')
sns.regplot(data, x = 'zoom level', y = 'ZARR', ax = ax, color=s11_cmap(255), ci = 95, label= 'ZARR')
ax.set_ylabel('Request time [s]')

a = plt.legend()
# a= sns.despine(trim = True, offset = -10, ax = ax)
```

